# First Colloquium Exercises

## Проблем 1: Управување со Песни и CD-а

### Класа `Pesna`
Класата `Pesna` се користи за чување на податоци за песните и содржи:
- **Име на песна**: Динамички алоцирано поле од знаци.
- **Времетраење**: Времетраење на песната во минути (цел број).
- **Тип на песна**: Енумерација `tip` со можни вредности: `поп`, `рап`, `рок`.

---

### Методи на `Pesna`

#### Конструктори и Деструктор
- **Конструктори**: Соодветни конструктори за иницијализација на објектите.
- **Деструктор**: За ослободување на динамички резервираната меморија.

#### Метод `pecati()`
- Ја печати песната во следниот формат:
  ```plaintext
  "име на песна"-времетраење min
  ```

---

### Класа `CD`
Класата `CD` се користи за управување со збирка на песни и содржи:
- **Низа од песни**: Поле од најмногу 10 објекти од класата `Pesna`.
- **Број на песни**: Цел број кој го чува бројот на песни на CD-то.
- **Максимално времетраење**: Максимално дозволено времетраење на сите песни на CD-то (во минути, цел број).

---

### Методи на `CD`

#### Конструктори и Деструктор
- **Конструктори**: Соодветни конструктори за иницијализација на објектите.
- **Деструктор**: За ослободување на ресурсите.

#### Метод `dodadiPesna(Pesna p)`
- Ја додава песната `p` на CD-то ако:
  - Има доволно преостанато место во времетраењето.
  - Има помалку од 10 песни на CD-то.

#### Метод `pecatiPesniPoTip(tip t)`
- Ги печати сите песни од типот `t` (поп, рап, или рок).
  - Форматот за печатење е ист како во методот `pecati()` од класата `Pesna`.


## Проблем 2: Листа и Контејнер за Листа

### Класа `List`
Класата `List` треба да ги чува следните информации:
- броеви што се дел од листата (динамички алоцирана низа од цели броеви)
- бројот на броеви што се дел од листата

#### Методи
За класата да се дефинираат следните методи:
1. **Конструктор** (со аргументи).
2. **Copy-конструктор**.
3. **Деструктор**.
4. **Оператор =**.
5. `void pecati()`: метод што ќе ги печати информациите за листата во форматот:
   ```
   [број на елементи во листата]: x1 x2 .. xn 
   sum: [сума] 
   average: [просек]
   ```
6. `int sum()`: метод што ја враќа сумата на елементите во листата.
7. `double average()`: метод што ќе го враќа просекот на броевите во листата.

---

### Класа `ListContainer`
Класата `ListContainer` треба да ги чува следните информации:
- низа од листи (динамички алоцирана низа од објекти од класата `List`)
- број на елементи во низата од листи (цел број)
- број на обиди за додавање на листа во контејнерот (цел број првично поставен на нула)

#### Методи
За класата потребно е да ги дефинирате следните методи:
1. **Конструктор** (default).
2. **Copy-конструктор**.
3. **Деструктор**.
4. **Оператор =**.
5. `void pecati()`: метод што ќе ги печати информациите за контејнерот во форматот:
   ```
   List number: [реден број на листата] 
   List info: [испечатени информации за листата со методот List::pecati()]

   sum: [сума] 
   average: [просек]
   ```
   Доколку контејнерот е празен се печати само порака `The list is empty.`
6. `void addNewList(List l)`: метод со којшто се додава листа во контејнерот.  
   - Една листа се додава во контејнерот **ако и само ако има различна сума** од сите листи што се веќе додадени во контејнерот.
7. `int sum()`: метод што ја враќа сумата на сите елементи во сите листи.
8. `double average()`: метод што го враќа просекот на сите елементи во сите листи во контејнерот.


## Проблем 3: Модул за менаџирање со клиентски портфолија

### Класа `StockRecord`
Класата `StockRecord` треба да содржи:
- **ID**: ознака за тоа која е акцијата која се тргува (низа од 12 знаци).
- **Име на компанијата**: име на компанијата која ја издала акцијата (низа од 50 знаци).
- **Цена според која се купени акциите**: реален број.
- **Моментална цена на акцијата**: реален број.
- **Број на акции**: број на акции кои се купени (цел број).

#### Методи
1. Потребни **конструктори**.
2. `void setNewPrice(double c)`: метода за поставување на нова моментална цена (10 поени).
3. `double value()`: метода која ја пресметува вредноста на акциите. 
   - **Вредност** = број на акции * моментална цена.
4. `double profit()`: метода која го пресметува моменталниот профит од акциите.
   - **Профит** = број на акции * (моментална цена - цена по која се купени).
5. Преоптоварување на операторот `<<` за печатење на објектот во следниот формат (5 поени):
   ```
   Компанија БројНаАкции КуповнаЦена МоменталнаЦена Профит
   ```

---

### Класа `Client`
Класата `Client` треба да содржи:
- **Име и презиме на клиентот**: низа од 60 знаци.
- **ID на сметка**: цел број.
- **Низа од компании**: динамичка низа од објекти од класата `StockRecord` кои ги поседува клиентот.
- **Број на објекти во низата**: цел број.

#### Методи
1. Потребни **конструктори** и **деструктор**.
2. `double totalValue()`: метода која ја пресметува моменталната вредност на акциите кои ги поседува клиентот (15 поени).  
   - Се пресметува како збир од вредноста на сите акции од секоја компанија од кои е составено клиентското портфолио.
3. Преоптоварување на операторот `+=` за купување на нова компанија во портфолиото (10 поени).  
   - Додавање на нов објект од класата `StockRecord` во низата со компании.
4. Преоптоварување на операторот `<<` за печатење на информации за портфолиото на клиентот (5 поени):
   - Во првиот ред ќе бидат прикажани **ID на сметката** и моменталната вредност на портфолиото, одделени со празно место.
   - Во секој нареден ред ќе бидат прикажани компаниите од кои е составено портфолиото, секоја во посебен ред.

---

### Бодовна структура
- `void setNewPrice(double c)`: 10 поени.
- Методи `value()` и `profit()`: 5 поени.
- Преоптоварување на операторот `<<` во `StockRecord`: 5 поени.
- `double totalValue()` во `Client`: 15 поени.
- Преоптоварување на операторот `+=` во `Client`: 10 поени.
- Преоптоварување на операторот `<<` во `Client`: 5 поени.
- Комплетна функционалност: 5 поени.


## Проблем 4: Организација на Патници во Воз

### Класа `Patnik`
Класата `Patnik` чува податоци за патниците на еден воз и содржи:
- **Име**: низа од максимум 100 знаци.
- **Класа на вагон**: цел број (1 или 2).
- **Велосипед**: булова променлива која означува дали патникот има велосипед.

#### Преоптоварувања
1. **Оператор `<<`**:
   - Печати ги информациите за патникот во следниот формат:
     ```
     Име на патник
     Бројот на класата (1 или 2)
     Дали има велосипед?
     ```

---

### Класа `Voz`
Класата `Voz` чува информации за возот и содржи:
- **Крајна дестинација**: низа од максимум 100 знаци.
- **Низа од патници**: динамички алоцирана низа од објекти од класата `Patnik`.
- **Број на елементи во низата**: цел број.
- **Број на дозволени велосипеди**: цел број.

#### Методи и преоптоварувања
1. **Оператор `+=`**:
   - Додавање нов патник во воз.
   - Патник со велосипед ќе може да се качи само ако возот го дозволува тоа.

2. **Оператор `<<`**:
   - Печати ја крајната дестинација и листата на патници во возот.

3. **Функција `patniciNemaMesto()`**:
   - Пресметува вкупниот број на патници со велосипеди (од 1-ва и 2-ра класа) за кои нема место да влезат во возот.
   - **Логика за пресметка**:
     - Прво се земаат предвид патниците од 1-ва класа.
     - Потоа се додаваат патници од 2-ра класа додека не се достигне максималниот број дозволени велосипеди.
   - На крај се печати бројот на патници со велосипеди кои остануваат надвор од возот, по класи (1-ва класа и 2-ра класа).


## Проблем 5: Менаџирање на Гитари во Магацин

### Класа `Gitara`
Класата `Gitara` чува информации за гитарите и содржи:
- **Сериски број**: низа од 25 знаци.
- **Набавна цена**: реален број.
- **Година на производство**: цел број.
- **Тип**: низа од 40 знаци.

#### Методи
1. **Метод `daliIsti`**:
   - Прима објект од тип `Gitara` како аргумент.
   - Ги споредува двете гитари според нивниот сериски број.

2. **Метод `pecati`**:
   - Печати ги информациите за гитарата во следниот формат:
     ```
     [СерискиБрој] [Тип] [Цена]
     ```

---

### Класа `Magacin`
Класата `Magacin` чува информации за магацинот и содржи:
- **Име на магацинот**: низа од 30 знаци.
- **Локација на магацинот**: низа од 60 знаци.
- **Низа од гитари**: динамички алоцирана низа од објекти од класата `Gitara`.
- **Број на објекти во низата**: цел број.
- **Година на отворање**: цел број.

#### Методи
1. **Метод `vrednost`**:
   - Пресметува моменталната вредност на гитарите во магацинот.
   - **Формула**: Збир од набавните цени на сите гитари во магацинот.

2. **Метод `dodadi`**:
   - Прима објект од тип `Gitara` како аргумент.
   - Додава нова гитара во динамички алоцираната низа на гитари.

3. **Метод `prodadi`**:
   - Прима објект од тип `Gitara` како аргумент.
   - Ги брише сите објекти од низата кои се исти како проследениот објект според серискиот број.

4. **Метод `pecati`**:
   - Прима булова променлива `daliNovi` како аргумент.
   - Печати информации за магацинот во следниот формат:
     ```
     Име на магацинот
     Локација на магацинот
     ```
   - Доколку `daliNovi` е `true`, се печатат само гитарите произведени по годината на отворање на магацинот.
   - Во спротивно, се печатат сите гитари.

---

### Забелешки
- Сите податочни членови во класите се приватни.
- За класите се дефинираат потребните конструктори, деструктор и сите останати методи за правилно функционирање на програмата.


## Проблем 6: Програма за опишување на забавен парк

### Структура `Vozenje`
Структурата `Vozenje` чува информации за адреналински возења во забавен парк и содржи:
- **Име на возењето**: низа од 100 знаци.
- **Времетраење во минути**: цел број.
- **Цена**: децимален број.
- **Дали има студентски попуст**: булова вредност (1 - да, 0 - не).

---

### Структура `ZabavenPark`
Структурата `ZabavenPark` чува информации за забавен парк и содржи:
- **Име на забавниот парк**: низа од 100 знаци.
- **Локација**: низа од 100 знаци.
- **Низа од адреналински возења**: низа од максимум 100 елементи од структурата `Vozenje`.
- **Број на елементи во низата**: цел број.

---

### Функции

#### Функција `print`
- Ги печати информациите за сите возења во забавниот парк во следниот формат:
  ```
  [Име на парк] [Локација]
  [Име1] [Времетраење1] [Цена1]
  [Име2] [Времетраење2] [Цена2]
  [Име3] [Времетраење3] [Цена3]
  ```

#### Функција `najdobar_park`
- Прима низа од променливи од типот `ZabavenPark`.
- Го печати името и локацијата на паркот кој е најефтин за посета од страна на студенти.
  - **Најефтин парк**: паркот што содржи најголем број возења со студентски попуст.
  - Ако повеќе паркови ги делат овие карактеристики, се избира паркот со најголемото времетраење од сите возења.

---

### Дополнителни информации
- Да се имплементира функцијата `main` за тестирање на структурите и функциите.


## Проблем 7: Програма за менаџирање на компјутерски игри

### Структура `Igrac`
Структурата `Igrac` чува информации за еден играч и содржи:
- **Корисничко име**: низа од 15 знаци.
- **Број на ниво**: цел број што покажува до кое ниво играчот е стигнат.
- **Број на освоени поени**: цел број што покажува колку поени има освоено играчот.

---

### Структура `KompjuterskaIgra`
Структурата `KompjuterskaIgra` чува информации за компјутерска игра и содржи:
- **Име на играта**: низа од 20 знаци.
- **Низа од играчи**: низа од најмногу 30 елементи од структурата `Igrac`.
- **Број на играчи**: цел број што покажува колку играчи моментално ја играат играта.

---

### Функции

#### Функција `najdobarIgrac`
- **Потпис**: `void najdobarIgrac(KompjuterskaIgra *lista, int n)`
- **Опис**: 
  - Прима низа од променливи од типот `KompjuterskaIgra` и нивниот број `n`.
  - Го наоѓа најдобриот играч од играта со најголема популарност (играта што ја играат најголем број на играчи).
  - Најдобар играч е оној кој има најголем број на освоени поени. Ако има повеќе играчи со ист максимален број на поени, најдобар е играчот со најголемо достигнато ниво.
  - Го печати корисничкото име на најдобриот играч и името на играта со следниот формат:
    ```
    Najdobar igrac e igracot so korisnicko ime XXXXX koj ja igra igrata YYYYYY
    ```
    - `XXXXX`: корисничко име на најдобриот играч.
    - `YYYYYY`: име на играта што ја играат најголем број на играчи.

---

### Дополнителни информации
- Да се имплементира функцијата `main` за тестирање на структурите и функциите.


## Проблем 8: Организација на Маратон и Учесници

### Класа `Ucesnik`
Класата `Ucesnik` претставува учесник во маратон и содржи:
- **Име**: динамички алоцирана низа од знаци.
- **Пол**: булова вредност (машки/женски).
- **Возраст**: цел број.

За оваа класа да се дефинираат:
- Потребните конструктори и деструктор. (10 поени)
- Оператор за споредување `>` за споредба на возраста на двајца учесници. (5 поени)
- Оператор за излезен тек `<<` за печатење на податоците за учесникот во формат:
  ```
  [Име]
  [Пол]
  [Возраст]
  ```


## Проблем 9: Управување со Пица и Пицерии

### Класа `Pica`
Класата `Pica` претставува пица и содржи:
- **Име на пицата**: низа од 15 знаци.
- **Цена**: цел број.
- **Состојки**: динамички алоцирана низа од знаци.
- **Намалување на цената**: цел број (во проценти, 0 ако пицата не е на промоција; во спротивно, вредност поголема од 0 и не поголема од 100).

За оваа класа да се дефинираат:
- Потребните конструктори и деструктор.
- Функции:
  - `pecati()` - печати податоци за пицата во формат:
    ```
    [Име] - [Состојки], [Цена]
    ```
  - `istiSe(Pica p)` - споредба на две пици според состојките.

---

### Класа `Picerija`
Класата `Picerija` чува податоци за пицерија и содржи:
- **Име**: низа од максимум 15 знаци.
- **Низа од `Pica` објекти**: динамички алоцирана низа од објекти од класата `Pica`.
- **Број на пици**: цел број.

За оваа класа да се дефинираат:
- Потребните конструктори и деструктор.
- Следниве методи:
  - `dodadi(Pica P)` - додавање нова пица во пицеријата, само ако не постои иста во низата (нема пица со исти состојки).
  - `piciNaPromocija()` - печати сите пици на промоција во формат:
    ```
    [Име] - [Состојки], [Цена], [Цена со попуст]
    

---

### Класа `Maraton`
Класата `Maraton` чува податоци за маратон и содржи:
- **Локација**: низа од максимум 100 знаци.
- **Низа од `Ucesnik` објекти**: динамички алоцирана низа од објекти од класата `Ucesnik`.
- **Број на учесници**: цел број.

За оваа класа да се дефинираат:
- Потребните конструктори и деструктор. (10 поени)
- Следните методи:
  - Оператор `+=` за додавање на нов `Ucesnik` на маратонот. (10 поени)
  - `prosecnoVozrast()` што ја враќа просечната возраст на учесниците. (5 поени)
  - `pecatiPomladi(Ucesnik &u)` што ги печати сите учесници помлади од проследениот учесник. (5 поени)


## Проблем 10: Управување со Планинарски Домови и Жичари

### Класа `Zichara`
Класата `Zichara` претставува жичара и содржи:
- **Место**: динамички алоцирано поле од знаци.
- **Цена на дневна карта**: цел број.

### Класа `PlaninarskiDom`
Класата `PlaninarskiDom` чува податоци за планинарски дом и содржи:
- **Име**: статичко поле од најмногу 15 знаци.
- **Цени по сезони**: поле од 2 цели броја (цената за летна сезона на индекс 0, за зимска сезона на индекс 1).
- **Класа на планинарскиот дом**: еден знак (A до F, каде A е најдобра класа).
- **Дали има жичара**: bool-тип.
- **Жичарата**: покажувач кон објект од класата `Zichara`.

За овие класи да се дефинираат:
- Потребните конструктори и деструктори.
- `set` и `get` методи.
- Преоптоварување на операторот `=`.

---

### Преоптоварување на оператори
- **Оператор `--` (префиксен)**: го намалува класата на планинарскиот дом за една буква (F е најмала класа).
- **Оператор `<<`**: за печатење на објект од класата `PlaninarskiDom` во формат:
  - Ако има жичара: `[Име] klasa:[Класа] so zichara`
  - Ако нема жичара: `[Име] klasa:[Класа]`
- **Оператор `<=`**: споредува дали планинарскиот дом има класа помала или еднаква со дадениот знак.

---

### Метод `presmetajDnevenPrestoj`
Функција за пресметување на цената за дневен престој во планинарскиот дом за даден ден и месец. 
- **Аргументи**:
  1. Ден (1-31).
  2. Месец (1-12).
  3. Цена за дневен престој (референца, вредноста се пресметува во функцијата).
- **Логика**:
  - Ако денот или месецот се невалидни, се фрла исклучок.
  - Ако има жичара, во цената се вклучува и дневната карта за жичарата.
  - Цената за летната сезона се користи за месеците од април до септември; за останатите месеци се користи цената за зимската сезона.

---

### Формат за печатење
- **Со жичара**: `[Име] klasa:[Класа] so zichara`
- **Без жичара**: `[Име] klasa:[Класа]


## Проблем 11: Управување со Датотеки и Директориуми

### Класа `File`
Класата `File` претставува датотека и содржи:
- **Име на датотеката**: динамички алоцирана низа од знаци.
- **Екстензија на датотеката**: енумација со можни вредности (`txt`, `pdf`, `exe`).
- **Име на сопственикот**: динамички алоцирана низа од знаци.
- **Големина**: цел број кој ја претставува големината на датотеката во мегабајти.

#### Методи за `File`
- **Конструктор без параметри**.
- **Конструктор со параметри**.
- **Конструктор за копирање**.
- **Деструктор**.
- **Оператор =** за доделување на вредности.
- **print()**: Метод за печатење на информациите за датотеката во следниот формат:
  ```
  [име].[екстензија] [сопственик] [големина]MB
  ```
- **equals(const File & that)**: Проверува дали две датотеки имаат исто име, екстензија и сопственик.
- **equalsType(const File & that)**: Проверува дали две датотеки имаат исто име и екстензија (тип).

---

### Класа `Folder`
Класата `Folder` претставува директориум и содржи:
- **Име на директориумот**: динамички алоцирана низа од знаци.
- **Број на датотеки**: цел број што ја претставува моменталната бројка на датотеки во директориумот.
- **Низа од датотеки**: динамички алоцирана низа од објекти од класата `File`.

#### Методи за `Folder`
- **Folder(const char* name)**: Конструктор кој го иницијализира директориумот со дадено име.
- **Деструктор**: Го ослободува динамичкиот мемориски простор.
- **print()**: Метод за печатење на информациите за директориумот во следниот формат:
  ```
  Folder: [име]
  [име1].[екстензија1] [сопственик1] [големина1]MB
  [име2].[екстензија2] [сопственик2] [големина2]MB
  ```
- **void add(const File & file)**: Метод за додавање нова датотека во директориумот, но само ако не постои датотека со исти состојки (проверка со `equals`).
- **void remove(const File & file)**: Метод за бришење на првата датотека што е еднаква на дадената (според `equals`).


## Проблем 12: Управување со Оперативни Системи и Репозиториуми

### Класа `OperativenSistem`
Класата `OperativenSistem` претставува модел за оперативен систем и содржи:
- **Име на оперативниот систем**: динамички алоцирана низа од знаци.
- **Верзија**: `float` кој ја претставува верзијата на системот.
- **Тип**: Енумација со можни вредности (`LINUX`, `UNIX`, `WINDOWS`).
- **Големина**: `float` кој ја претставува големината на оперативниот систем во GB.

#### Методи за `OperativenSistem`
- **Конструктор без параметри**.
- **Конструктор со параметри**.
- **Конструктор за копирање**.
- **Деструктор**.
- **Оператор =** за доделување на вредности.
- **pecati()**: Метод за печатење на информациите за оперативниот систем во следниот формат:
  ```
  [име] [верзија] [тип] [големина]GB
  ```
- **ednakviSe(const OperativenSistem &os)**: Проверува дали два оперативни системи имаат исто име, верзија, тип и големина.
- **sporediVerzija(const OperativenSistem &os)**: Споредува верзии на два оперативни системи и враќа:
  - `0` ако верзиите се исти,
  - `-1` ако верзијата на дадениот оперативен систем е поголема,
  - `1` во спротивен случај.
- **istaFamilija(const OperativenSistem &os)**: Проверува дали два оперативни системи се од иста фамилија (исто име и ист тип).

---

### Класа `Repozitorium`
Класата `Repozitorium` претставува складиште за оперативни системи и содржи:
- **Име на репозиториумот**: статичко поле од најмногу 20 знаци.
- **Низа од оперативни системи**: динамички алоцирана низа од објекти од класата `OperativenSistem`.
- **Број на оперативни системи**: цел број што ја претставува моменталната бројка на системи во репозиториумот.

#### Методи за `Repozitorium`
- **Repozitorium(const char *ime)**: Конструктор кој го иницијализира репозиториумот со дадено име.
- **Деструктор**: Го ослободува динамичкиот мемориски простор.
- **pecatiOperativniSistemi()**: Метод за печатење на сите оперативни системи во репозиториумот во следниот формат:
  ```
  [име] [верзија] [тип] [големина]GB
  ```
- **void dodadi(const OperativenSistem &nov)**: Метод за додавање нов оперативен систем со следното однесување:
  - Ако постои оперативен систем од иста фамилија кој е постар (помала верзија), се заменува со новиот систем.
  - Во спротивно, новиот систем се додава како дополнителен.
- **void izbrishi(const OperativenSistem &os)**: Метод за бришење оперативен систем од репозиториумот ако тој постои (споредба со `ednakviSe`).


## Проблем 13: Управување со Скијачки Центри и Лифтови

### Структура `SkiLift`
Структурата `SkiLift` се користи за чување на податоци за ски лифтовите и содржи:
- **Име на ски лифтот**: Низа од најмногу 15 знаци.
- **Максимален број на корисници**: Цел број што ја претставува максималната бројка на корисници кои можат да се опслужат на едно возење.
- **Дали е во функција**: Логичка вредност (`true` или `false`).

---

### Структура `SkiCenter`
Структурата `SkiCenter` се користи за чување на податоци за скијачки центри и содржи:
- **Име на скијачкиот центар**: Низа од најмногу 20 знаци.
- **Држава**: Низа од најмногу 20 знаци.
- **Низа од ски лифтови**: Може да содржи до 20 објекти од типот `SkiLift`.
- **Број на ски лифтови**: Цел број кој ја претставува моменталната бројка на лифтови во центарот.

---

### Функција `najgolemKapacitet`
Функцијата `najgolemKapacitet` се користи за пронаоѓање и печатење на ски центарот со најголем капацитет за опслужување на скијачи.

#### Потпис на функцијата
```cpp
void najgolemKapacitet(SkiCenter *sc, int n);
```

#### Опис на функцијата
1. **Аргументи:**
   - `sc`: Покажувач кон низа од објекти од типот `SkiCenter`.
   - `n`: Број на ски центри во низата.

2. **Пресметка на капацитет:**
   - За секој ски центар, се пресметува вкупниот капацитет на сите ски лифтови кои се во функција.
   - Капацитетот на еден ски центар е збир од капацитетите на сите лифтови кои се во функција (`funkcija == true`).

3. **Критериуми за избор:**
   - Ако два или повеќе центри имаат ист капацитет, се избира центарот со поголем број на ски лифтови.

4. **Резултат:**
   - На излез се печатат името, државата и капацитетот на центарот со најголем капацитет.

#### Формат на излезот
```plaintext
[Име на центарот]
[Држава]
[Капацитет]
```

## Проблем 14: Управување со Продавница за Сладолед

### Класа `IceCream`
Класата `IceCream` се користи за чување на податоци за сладоледите и содржи:
- **Име**: Динамички алоцирана низа од знаци.
- **Состав**: Низа од знаци (најмногу 100).
- **Цена**: Децимален број.
- **Попуст**: Цел број (проценти, иницијално 0).

---

### Методи и Оператори на `IceCream`

#### Конструктори и Деструктор
- **Конструктори**: Соодветни конструктори за иницијализација на објектите.
- **Деструктор**: За ослободување на динамички резервираната меморија.

#### Оператор `<<`
- Овозможува печатење на податоците за сладоледот во следниот формат:
  ```plaintext
  име: состав цена [цена на попуст]
  ```
  Делот „цена на попуст“ се печати само ако вредноста на попустот е поголема од 0.

#### Оператор `++` (Префикс)
- Го зголемува попустот за 5.

#### Оператор `+`
- Собирање на објект од класата `IceCream` со низа од знаци.
  - Новото име е спој од постојното име и низата од знаци, одделени со „ + “.
  - Цената се зголемува за 10, додека попустот и составот остануваат исти.

#### Метод `setDiscount(int discount)`
- Ја поставува вредноста на попустот.
- Попустот мора да биде во интервалот `[0, 100]`.

#### Метод `setName(char* name)`
- Го менува името на сладоледот.

---

### Класа `IceCreamShop`
Класата `IceCreamShop` се користи за управување со продавницата и содржи:
- **Име на продавницата**: Низа од најмногу 50 знаци.
- **Низа од сладоледи**: Динамички резервирано поле од објекти од класата `IceCream`.
- **Број на сладоледи**: Цел број.

---

### Методи и Оператори на `IceCreamShop`

#### Конструктори и Деструктор
- **Конструктори**: За иницијализација на продавницата.
- **Деструктор**: За ослободување на динамички резервираната меморија.

#### Оператор `+=`
- Овозможува додавање на нов објект од класата `IceCream` во низата на сладоледи.

#### Оператор `<<`
- Го печати името на продавницата и податоците за сите сладоледи, секој на нов ред.

